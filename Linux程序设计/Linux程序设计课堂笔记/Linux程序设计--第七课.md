# Linux程序设计--第七课

> By Leonezhurui, Software Engineering



文件名：

`.c`：C源码

`.i`：经预处理的文件

`.cc/.cp/.cpp/.CPP/.c++/.C/.cxx`：C++的扩展名

`.ii`：C++经过预处理的文件

`.h`：头文件

`.H`：经过预处理的头文件

`.hh`：C++头文件

`.s`：其实就是汇编代码

`.S`：经过预处理的汇编代码

`.o`：目标文件

`.a`：静态库文件

`.so`：动态库文件

==注意：这里ppt上可能存在问题，对于`.i`和`.c`文件的含义==



* GDB: GNU Debug
  * 设置断点
  * 监视变量值
  * 单步执行
  * 修改变量值



==gdb????==(知道基本命令就ok)



| gdb命令      | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| file         | 打开要调试的文件                                             |
| run          | 执行当前调试的程序                                           |
| **list**     | 列出源代码的一部分                                           |
| next         | 执行一条语句但不进入函数内部                                 |
| step         | 执行一条语句，是函数则进入函数内部                           |
| display      | 显示表达式的值                                               |
| print        | 临时显示表达式的值                                           |
| kill         | 中止正在调试的程序                                           |
| quit         | 退出gdb                                                      |
| shell        | 不退出gdb就执行shell命令                                     |
| make         | 不退出gdb就执行make                                          |
| break/tbreak | 设置断点，可以是行号、函数名及地址(以*开头)<br />tbreak：设置临时断点 |



## make & makefile

* Multi-file project
  * IDE
  * make
* make & makefile
  * makefile描述模块间的依赖关系；
  * make命令根据makefile对程序进行管理和维护；make判断被维护文件的时序关系



Hello的makefile

```makefile
TOPDIR = ../
include $(TOPDIR)Rules.mak
EXTRA_LIBS +=
EXEC = $(INSTALL_DIR)/hello
OBJS = hello.o
# 变量定义，makefile可以include别的makefile
# 变量定义的时候，等号两边可以添加空格

all: $(EXEC)
$(EXEC): $(OBJS)
$(CC) $(LDFLAGS) -o $@ $(OBJS) $(EXTRA_LIBS)
install:
$(EXP_INSTALL) $(EXEC) $(INSTALL_DIR)

clean:
-rm -f $(EXEC) *.elf *.gdb *.o # $(EXEC)表示可执行文件
```



makefile

* **定义整个工程的编译规则**
  * 一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。
* **自动化编译**
  * **只需要一个make命令**，整个工程完全自动编译；
  * make是一个命令工具，是一个解释makefile中指令的命令工具；



makefile语法：

1. 默认情况下，每执行一条 makefile 中的命令之前，**Shell 终端都会显示出这条命令的具体内容**，除非该命令用分号分隔而紧跟在依赖关系后面，我们称之为“回显”。如果不想显示命令的具体内容，我们可以在命令的开头加上“@”符号，这种情况通常用于 echo 命令。
2. `${MAKE}`就是预设的 make 这个命令的名称（或者路径）。





* GNU make是一个命令工具，是一个用来控制软件构建过程的自动化管理工具。Make工具通过称为Makefile的文件来完成并自动维护编译工作,由RichardStallman 与RolandMcGrath设计开发。
* Makefile是用于自动编译和链接的，一个工程有很多文件组成，每一个文件的改变都会导致工程的重新链接，但是不是所有的文件都需要重新编译，Makefile中记录有文件的信息，在make时会决定在链接的时候需要重新编译哪些文件。
* make命令格式：`make [-f Makefile] [option] [target] `
* `#make target #make #make clean`

make install是需要root权限的

如果config的时候使用root权限，则编译后产生的所有文件都需要root权限。

直接make命令，则**执行的就是编译链接的部分**。

```shell
# automake方式
./configure #生成新的makefile
make
make install
make uninstall
make clean
make distclean# 退回到configure之前(删除makefile)
```





make

* `make [-f filename] [targetname]`

* Targets
  * A target is usually the name of a file that is generated by a program; examples of targets are executable or object files.
  * A target can also be the name of an action to carry out, such as 'clean' (phony target).



Makefile 规则结构

* **target ... : prerequisites **

  **...command......**

* target是一个目标文件，可以是Object File，也可以是执行文件

* prerequisites是要生成target所需要的文件或是目标

* command是make需要执行的命令。（可以是任意的Shell命令）

* 举例

```makefile
hello : main.o kbd.o 
	gcc -o hello main.o kbd.o # 执行部分写的是规则，并不是顺序执行的
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c 
clean :
	rm edit main.o kbd.o 
```

只是匹配次序，并不是执行次序。

make的执行：时间戳检查、文件检查





Makefile执行次序

1. make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
2. 查找文件中的第一个目标文件（target），举例中的hello
3. 如果hello文件不存在，或是hello所依赖的文件修改时间要比hello新，就会执行后面所定义的命令来生成hello文件。
4. 如果hello所依赖的.o文件不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（类似一个堆栈的过程）
5. make根据.o文件的规则生成.o 文件，然后再用.o 文件生成hello文件。



**伪目标**

```makfile
clean:
	rm *.o hello
```

* “伪目标”**并不是一个文件**，**只是一个标签**，所以make无法生成它的依赖关系和决定它是否要执行，只能通过显示地指明这个“目标”才能让其生效
* “伪目标”的**取名不能和文件名重名**
* 为了避免和文件重名的这种情况，可以使用一个特殊的标记**“.PHONY”来显示地指明一个目标是“伪目标”**，向make说明，不管是否有这个文件，这个目标就是“伪目标”
* 伪目标一般没有依赖的文件，但也可以为伪目标指定所依赖的文件。
* 伪目标同样可以作为“默认目标”，只要将其放在第一个。

一般情况下，`make`会默认执行第一个命令；且一般第一个伪目标就是`all`，所以敲不敲`all`都差不多。



多目标

* 用处
* 当多个目标同时依赖于一个文件，并且其生成的命令大体类似，可以使用一个自动化变量**“$@”表示着目前规则中所有的目标的集合**
* 举例

```makefile
bigoutput littleoutput : text.ggenerate text.g -$(subst output,,$@) > $@ 
```

`$@`

`subst output,,$@`：是makefile预定义的一个小函数，subst是子串的意思，将`$@`中的output替换成空`,,`。

上述规则等价于

```makefile
bigoutput : text.g
	generate text.g -big > bigoutput

littleoutput : text.g
	generate text.g -little > littleoutput 
```



```makefile
目标: 依赖
	命令
```





预定义变量

* `$<`**第一个依赖文件的名称**
* `$?`**所有的依赖文件**，以空格分开，这些依赖文件的**修改日期比目标的创建日期晚**(需要更新的依赖文件)
* `$+`**所有的依赖文件**，以空格分开，并以出现的先后为序，可能包含重复的依赖文件
* `$^`**所有的依赖文件**，以空格分开，**不包含重复的依赖文件**
* `$*`**不包括扩展名的目标文件名称**
* `$@`目标的完整名称
* `$%`如果目标是归档成员(.a或.so)，则该变量表示目标的归档成员名称



```makefile
edit:main.okbd.ocommand.odisplay.o\
	insert.o search.o files.o utils.o 
	gcc -o edit main.o kbd.o command.o display.o\
	insert.o search.o files.o utils.o main.o:main.c defs.h 
	gcc -c main.c 
kbd.o:kbd.c defs.h command.h 
	gcc -c kbd.c 
command.o:command.c defs.h command.h 
	gcc -c command.c 
display.o:display.c defs.h buffer.h 
	gcc -c display.c 
insert.o:insert.c defs.h buffer.h 
	gcc -c insert.c 
search.o:search.c defs.h buffer.h 
	gcc -c search.c 
files.o:files.c defs.h buffer.h command.h 
	gcc -c files.c 
utils.o:utils.c defs.h 
	gcc -c utils.c 
clean:
	rm edit main.o kbd.o command.o display.o\
	insert.o search.o files.o utils.o
```

进行简化：将所有的目标文件设置成变量

```makefile
OBJECTS=main.okbd.ocommand.odisplay.o\insert.osearch.ofiles.outils.o

edit:$(OBJECTS) gcc-oedit$(OBJECTS) main.o:main.cdefs.h gcc-cmain.c kbd.o:kbd.cdefs.hcommand.h gcc-ckbd.c command.o:command.cdefs.hcommand.h gcc-ccommand.c display.o:display.cdefs.hbuffer.h gcc-cdisplay.c insert.o:insert.cdefs.hbuffer.h gcc-cinsert.c search.o:search.cdefs.hbuffer.h gcc-csearch.c files.o:files.cdefs.hbuffer.hcommand.h gcc-cfiles.c utils.o:utils.cdefs.h gcc-cutils.c clean: rmedit$(OBJECTS)
```





多目标扩展

* 语法

`<targets ...>: <target-pattern>: <prereq-patterns ...><commands>... `

* 举例

```makefile
objects = foo.o bar.o
all: $(objects)
$(objects): %.o: %.c
	$(CC) -c $(CFLAGS) $< -o $@
```

* 目标从$object中获取
* “%.o”表明要所有以“.o”结尾的目标，即“foo.o bar.o”，就是变量$object集合的模式
* 依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是依赖的目标就是“foo.c bar.c”



上述规则等价于

```makefile
foo.o : foo.c$(CC) -c $(CFLAGS) foo.c -o foo.o

bar.o : bar.c$(CC) -c $(CFLAGS) bar.c -o bar.o 
```





使用函数

* 调用语法
  * `$(<function> <arguments>) `
  * `${<function> <arguments>} `
* 字符串处理函数
  * `$(subst <from>,<to>,<text>)`字符串替换
  * `$(strip <string>)`将一个字符串的开头结尾的空格之类的去除==注意：这里也是有问题的，我测试的strip函数会将多余的空格变成一个空格，例如"    sutaorui  niude "就会变成" sutaorui niude"==
  * ……
* 文件名操作函数
  * `$(dir <names...>)`
  * `$(basename <names...>)`
  * ……
* **foreach** 函数
  * `$(foreach <var>,<list>,<text>)`
* **if** 函数
  * `$(if <condition>,<then-part>) `
  * `$(if <condition>,<then-part>,<else-part>) `
* **call**函数
  * `$(call <expression>,<parm1>,<parm2>,<parm3>...) `
* ……

```makefile
names = a b c d
files = $(foreach, n, $names, $(n).o)
```



```makefile
reverse = $(2) $(1)
$(call reverse, a, b)
# 则输出的就是ba
```





软件设计原则

* 清晰原则
* 吝啬原则
* 扩展原则





