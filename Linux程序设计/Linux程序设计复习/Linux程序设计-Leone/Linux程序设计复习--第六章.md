# Linux程序设计复习--第六章

## Linux内核概念(背)

什么是内核

* 操作系统是一系列程序的集合，其中最重要的部分构成了内核
* 单内核/微内核
  - 单内核是一个很大的进程，内部可以分为若干模块，运行时是一个独立的二进制文件，模块间通讯通过直接调用函数实现
  - 微内核中大部分内核作为独立的进程在特权下运行，通过消息传递进行通讯
* Linux内核的能力
  * **内存管理**，**文件系统**，**进程管理**，多线程支持，抢占式，多处理支持
* Linux内核区别于其他UNIX商业内核的优点
  * 单内核，模块支持
  * 免费/开源
  * 支持多种CPU，硬件支持能力非常强大
  * Linux开发者都是非常出色的程序员
  * 通过学习Linux内核的源码可以了解现代操作系统的实现原理

![Linux内核层次结构](../rui文档/大三第二学期/学期一/Linux程序设计/Linux程序设计课堂笔记/img/Linux内核层次结构.png)



## initrd命令

初始化程序的建立

* initrd
  * mkinitrd /boot/initrd.img $(uname -r)
* initramfs
  * mkinitramfs -o /boot/initrd.img 2.6.24-16
  * update-initramfs -u





初始化内存盘INITRD(INITial Ram Disk)技术





## .ko文件

.ko文件是kernel object文件（内核模块），该文件的意义就是把内核的一些功能移动到内核外边， 需要的时候插入内核，不需要时卸载。



### 加载模块命令

* 底层命令 
  * insmod 
  * rmmod
* 高层命令
  * modprobe
  * modprobe -r



**insmod和modprobe区别**：

modprobe和insmod类似，都是用来动态加载驱动模块的。

区别在于modprobe可以**解决load module时的依赖关系**，它是通过/lib/modules/#uname -r/modules.dep(.bb)文件来查找依赖关系的；而insmod不能解决依赖问题。

也就是说，如果你确定你要加载的驱动模块不依赖其他驱动模块的话，既可以insmod也可以modprobe，当然insmod可以在任何目录下执行，更方便一些。

而如果你要加载的驱动模块还依赖其他ko驱动模块的话，就只能将模块拷贝到上述的特定目录，depmod后再modprobe。





## 内核程序和用户态程序的区别(背)

|      | C语言程序 | Linux内核模块                                                |
| ---- | --------- | ------------------------------------------------------------ |
| 运行 | 用户空间  | 内核空间                                                     |
| 入口 | main()    | module_init()指定(insmod会调用到这个函数，并不能算是入口；作为内核程序是没有入口和出口，开机之后就会一直在内存中，知道你关机之后才会退出) |
| 出口 | 无        | module_exit()指定                                            |
| 运行 | 直接运行  | insmod                                                       |
| 调试 | gdb       | kdbug，kdb，kgdb                                             |

注意点(内核程序开发)

* **不能使用C库来开发驱动程序**
* **没有内存保护机制**(在用户态中，如果发生内存泄漏，则这个进程会被杀死，其他的进程还是可以运行的。但是在内核态中，是不会被发现的；内存泄漏在内核态是十分严重的)
* 小内核栈(调用的层数是受限的，基本上是不使用递归算法的，要控制其递归调用栈的大小的)
* 并发上的考虑(多核的话高度并行；单核的话是高度并发的)



## 驱动

字符设备驱劢程序的初始化加载过程

- 申请设备号
- 定义文件操作结构体 file_operations
- 创建并初始化定义结构体 cdev
- 将cdev注册到系统，并和对应的设备号绑定
- 在/dev文件系统中用mknod创建设备文件， 并将该文件绑定到**设备号**上